# Assignment 1

In this assignment, we'll explore consensus more in depth. We worked with a basic blockchain in Express.js in the first class. Your task is to modify this blockchain to have Proof-of-Work consensus.

## Proof-of-Work

Recall, PoW is a piece of data that is difficult to produce but easy to verify. A computationally difficult problem could involve using the SHA256 hash function. While we'll explore this function in depth next week, it suffices to view it as a function that takes any string and produces a unique string of fixed length. Even if the difference between both strings is trivial, the difference between their hashes is quite large. For example:

SHA256("The quick brown fox jumped over the lazy dogs.") = c9c85caa5a93aad2bfcc91b9a02d4185a0f0348aac049e650bd0f4dea10a7393
SHA256("The quick brown fox jumped over the lazy dog.") = 68b1282b91de2c054c36629cb8dd447f12f096d3e3c587978dc2248444633483

This is a pretty neat property. We can exploit this apparent randomness of SHA256 outputs to create a PoW algorithm. Say you have a base string to work with, "CSBC2000". We can create an arbitrarily hard problem by setting expectations about SHA256 outputs. Specifically, say we also have a random string generator function `nonce()` that returns a random string each time you use it. We can create a problem where we expect the output of `SHA256("CSBC2000" + nonce())` to have at least 5 continuous `a`s in the beginning. Now this is quite a difficult problem as a SHA256 hash has 32 bytes and we are expecting the first 5 bytes to all be the same. The only feasible way of finding a nonce value that fits this constraint is by continuously calling the SHA256 function as mentioned over and over again. On the flip side, it is very easy to verify the correctness of a solution as you just need to call SHA256 with the provided nonce value to verify. Let's pretend `01a3efgt` is the correct nonce; the verifier would just need to call `SHA256("CSBC2000" + "01a3efgt")` and check if the output has 5 successive `a`s in the beginning.

## Assignment guidelines

The `nonce` value is being used in various functions but has a `0` value by default. We need to modify it to actually be found and generated by a PoW algorithm. Your task is to complete the `proofOfWork` function body and make it return the actual nonce for the block. You can start by getting the hash of the pending transactions for a block using the `getHash` function with an empty nonce and continuously change the nonce until you find a hash value that satisfies your constraint. I'll accept any interesting constraint but a basic one you can test with is having the first 3 bytes of your hash being `0`.
After this, make sure the nonce is being used correctly in the rest of the program, and that the blockchain remains valid (i.e. the test in the bottom passes)!

## Bonus Points

- You can add a difficulty param that increases the difficulty of PoW after some number of blocks.
- You can compute the average hash rate by using timestamps and calculating the average time taken to mine a block. this is more interesting with higher difficulty PoW.
